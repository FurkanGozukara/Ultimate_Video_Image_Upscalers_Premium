"""
Automatic Preset Serialization System

This module provides automatic detection and serialization of Gradio components
to eliminate manual ORDER list maintenance.

Features:
- Auto-detect all input components in a tab
- Generate serialization order from component tree
- Validate preset compatibility with current UI
- Auto-migrate old presets to new schema

Usage:
    Instead of manually maintaining SEEDVR2_ORDER = [...],
    use auto_detect_inputs(component_list) to generate dynamically.
"""

from typing import Any, Dict, List, Optional, Tuple
import gradio as gr


def get_component_value(component: gr.components.Component) -> Any:
    """
    Extract current value from a Gradio component.
    
    Args:
        component: Any Gradio component
        
    Returns:
        Current value of the component
    """
    # Get value based on component type
    if hasattr(component, 'value'):
        return component.value
    elif isinstance(component, gr.State):
        return component.value if hasattr(component, 'value') else None
    else:
        # Fallback for components without value attribute
        return None


def get_component_key(component: gr.components.Component, index: int) -> str:
    """
    Generate a stable key for a component.
    
    Args:
        component: Gradio component
        index: Position in component list
        
    Returns:
        Unique key string
    """
    # Try to use component label or elem_id as key
    if hasattr(component, 'label') and component.label:
        # Sanitize label to create valid key
        key = component.label.lower()
        key = key.replace(" ", "_").replace("-", "_")
        key = "".join(c for c in key if c.isalnum() or c == "_")
        return key
    elif hasattr(component, 'elem_id') and component.elem_id:
        return component.elem_id
    else:
        # Fallback to index-based key
        return f"param_{index:03d}"


def auto_detect_inputs(
    components: List[gr.components.Component],
    prefix: str = ""
) -> Tuple[List[str], Dict[str, Any]]:
    """
    Automatically detect and serialize Gradio components.
    
    Args:
        components: List of Gradio components (inputs_list)
        prefix: Optional prefix for keys (e.g., "seedvr2_")
        
    Returns:
        (ordered_keys, default_values) tuple
        - ordered_keys: List of stable keys for serialization
        - default_values: Dict mapping keys to current values
    """
    ordered_keys = []
    default_values = {}
    
    for idx, component in enumerate(components):
        key = prefix + get_component_key(component, idx)
        value = get_component_value(component)
        
        ordered_keys.append(key)
        default_values[key] = value
    
    return ordered_keys, default_values


def serialize_component_values(
    components: List[gr.components.Component],
    ordered_keys: List[str]
) -> Dict[str, Any]:
    """
    Serialize current component values to dictionary.
    
    Args:
        components: List of components
        ordered_keys: Keys generated by auto_detect_inputs
        
    Returns:
        Dictionary mapping keys to current values
    """
    if len(components) != len(ordered_keys):
        raise ValueError(f"Component count mismatch: {len(components)} vs {len(ordered_keys)} keys")
    
    result = {}
    for key, component in zip(ordered_keys, components):
        result[key] = get_component_value(component)
    
    return result


def deserialize_to_component_values(
    preset: Dict[str, Any],
    ordered_keys: List[str],
    current_values: Optional[List[Any]] = None
) -> List[Any]:
    """
    Deserialize preset dictionary to component value list.
    
    Args:
        preset: Preset dictionary (can have subset of keys)
        ordered_keys: Keys in order
        current_values: Current component values (for fallback)
        
    Returns:
        List of values in component order
    """
    result = []
    
    for idx, key in enumerate(ordered_keys):
        if key in preset:
            # Use preset value
            result.append(preset[key])
        elif current_values and idx < len(current_values):
            # Fallback to current value (preset doesn't have this key yet)
            result.append(current_values[idx])
        else:
            # Fallback to None
            result.append(None)
    
    return result


def migrate_legacy_preset(
    legacy_preset: Dict[str, Any],
    legacy_order: List[str],
    new_keys: List[str]
) -> Dict[str, Any]:
    """
    Migrate old preset from indexed list to new key-based format.
    
    Args:
        legacy_preset: Old preset (may be list or dict)
        legacy_order: Old ORDER list
        new_keys: New auto-detected keys
        
    Returns:
        Migrated preset dictionary
    """
    # If already a dict with new keys, return as-is
    if isinstance(legacy_preset, dict) and all(k in new_keys for k in legacy_preset.keys()):
        return legacy_preset
    
    # If it's a list, convert using legacy order
    if isinstance(legacy_preset, list):
        migrated = {}
        for idx, key in enumerate(legacy_order):
            if idx < len(legacy_preset):
                # Find corresponding new key
                if key in new_keys:
                    migrated[key] = legacy_preset[idx]
        return migrated
    
    # If it's a dict with old keys, try to map to new keys
    if isinstance(legacy_preset, dict):
        migrated = {}
        for old_key, value in legacy_preset.items():
            # Try to find matching new key
            if old_key in new_keys:
                migrated[old_key] = value
            else:
                # Try fuzzy match
                for new_key in new_keys:
                    if old_key.lower().replace("_", "") == new_key.lower().replace("_", ""):
                        migrated[new_key] = value
                        break
        return migrated
    
    return legacy_preset


class AutoPresetManager:
    """
    Enhanced preset manager with automatic serialization.
    
    Wraps existing PresetManager and adds auto-detection capabilities.
    """
    
    def __init__(self, base_preset_manager, tab_name: str):
        self.base_manager = base_preset_manager
        self.tab_name = tab_name
        self._detected_keys: Optional[List[str]] = None
        self._legacy_order: Optional[List[str]] = None
    
    def register_components(
        self,
        components: List[gr.components.Component],
        legacy_order: Optional[List[str]] = None
    ):
        """
        Register components for auto-serialization.
        
        Args:
            components: List of UI components
            legacy_order: Optional legacy ORDER list for migration
        """
        self._detected_keys, _ = auto_detect_inputs(components, prefix=f"{self.tab_name}_")
        self._legacy_order = legacy_order
    
    def save_auto(
        self,
        model_name: str,
        preset_name: str,
        components: List[gr.components.Component]
    ) -> bool:
        """
        Automatically save preset from current component values.
        
        Args:
            model_name: Model identifier
            preset_name: Name for preset
            components: List of components to serialize
            
        Returns:
            True if successful
        """
        if not self._detected_keys:
            self.register_components(components)
        
        preset_data = serialize_component_values(components, self._detected_keys)
        
        try:
            self.base_manager.save_preset_safe(
                self.tab_name,
                model_name,
                preset_name,
                preset_data
            )
            return True
        except Exception:
            return False
    
    def load_auto(
        self,
        model_name: str,
        preset_name: str,
        current_values: List[Any]
    ) -> List[Any]:
        """
        Automatically load preset and deserialize to component values.
        
        Args:
            model_name: Model identifier
            preset_name: Preset to load
            current_values: Current component values (for fallback)
            
        Returns:
            List of values to apply to components
        """
        if not self._detected_keys:
            raise RuntimeError("Components not registered. Call register_components() first.")
        
        preset = self.base_manager.load_preset_safe(self.tab_name, model_name, preset_name)
        
        if not preset:
            return current_values
        
        # Migrate if needed
        if self._legacy_order and isinstance(preset, (list, dict)):
            preset = migrate_legacy_preset(preset, self._legacy_order, self._detected_keys)
        
        return deserialize_to_component_values(preset, self._detected_keys, current_values)


# Convenience function for backward compatibility
def create_auto_order(
    components: List[gr.components.Component],
    manual_keys: Optional[List[str]] = None
) -> List[str]:
    """
    Create ORDER list automatically or validate against manual list.
    
    Args:
        components: UI components
        manual_keys: Optional manual key list to validate
        
    Returns:
        Order list (auto-detected or validated manual)
    """
    auto_keys, _ = auto_detect_inputs(components)
    
    if manual_keys:
        # Validate manual keys match component count
        if len(manual_keys) != len(components):
            print(f"⚠️ Warning: Manual keys ({len(manual_keys)}) don't match components ({len(components)})")
            print(f"Auto-detected keys: {auto_keys}")
            return auto_keys
        return manual_keys
    
    return auto_keys

